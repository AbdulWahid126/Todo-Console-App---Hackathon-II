---
id: 4
title: Phase II Analysis
stage: tasks
date: 2026-01-18
surface: agent
model: claude-sonnet-4-5-20250929
feature: phase-ii
branch: phase-ii-fullstack-web-app
user: user
command: sp.analyze
labels: [analysis, phase-ii, compliance, review]
links:
  spec: specs/phase-ii/spec.md
  plan: specs/phase-ii/plan.md
  tasks: specs/phase-ii/tasks.md
  constitution: .specify/memory/constitution.md
files:
  - specs/phase-ii/spec.md
  - specs/phase-ii/plan.md
  - specs/phase-ii/tasks.md
  - backend/models/todo.py
  - backend/services/todo_service.py
  - backend/api/v1/todos.py
tests:
  - none
---

## Prompt

```text
$ARGUMENTS

Phase: II â€” Full-Stack Web Todo Application

Read the existing speckit.constitution
and the Phase II specification generated by /specify.

Create a detailed implementation plan describing HOW the system will be built.

Include

## 1. High-Level Architecture

### 1.1 System Overview

**Three-Tier Architecture**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Browser (Client Tier)           â”‚
â”‚    Next.js App Router Application       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚ HTTP/REST (JSON)
               â”‚ Port: 3000 â†’ 8000
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Application Tier (Backend)         â”‚
â”‚         FastAPI REST Server             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚ SQL/ORM
               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Data Tier (Persistence)         â”‚
â”‚      SQLite Database (File-based)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 Technology Stack Rationale

**Frontend: Next.js 14+ (App Router)**
- Server Components for initial page structure (non-data)
- Client Components for interactive todo operations
- Built-in routing with file-system based conventions
- Native support for loading and error boundaries
- TypeScript for type safety across API contracts

**Backend: FastAPI**
- Native async/await for concurrent request handling
- Automatic request/response validation via Pydantic
- Auto-generated OpenAPI documentation
- Python ecosystem for rapid development
- Built-in dependency injection for database sessions

**Database: SQLite**
- File-based persistence (survives restarts)
- Zero configuration required
- Sufficient for single-node deployment
- ACID compliance for data integrity
- Easy migration path to PostgreSQL if needed

**Communication Protocol: REST over HTTP**
- Stateless request/response model
- Standard HTTP methods map to CRUD operations
- JSON serialization for universal compatibility
- CORS middleware for cross-origin development

### 1.3 Deployment Model (Development)

**Two-Process Architecture**
- Frontend dev server: `localhost:3000` (Next.js)
- Backend API server: `localhost:8000` (FastAPI)
- Database file: `./data/todos.db` (SQLite)
- Frontend proxies API requests to backend during development

**Network Flow**
1. User browser â†’ `localhost:3000` (Next.js serves UI)
2. Client-side fetch â†’ `localhost:3000/api/*` (Next.js route)
3. Next.js API route â†’ `localhost:8000/todos` (FastAPI backend)
4. FastAPI â†’ SQLite database file
5. Response flows back through chain

---

## 2. Frontend Architecture

### 2.1 App Router Structure

**Directory Layout Philosophy**
```
app/
â”œâ”€â”€ layout.tsx              # Root layout (nav, metadata)
â”œâ”€â”€ page.tsx                # Home page (redirects to /todos)
â”œâ”€â”€ todos/
â”‚   â”œâ”€â”€ page.tsx            # Todo list view (Client Component)
â”‚   â”œâ”€â”€ new/
â”‚   â”‚   â””â”€â”€ page.tsx        # Create todo form (Client Component)
â”‚   â””â”€â”€ [id]/
â”‚       â””â”€â”€ edit/
â”‚           â””â”€â”€ page.tsx    # Edit todo form (Client Component)
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ TodoList.tsx        # List rendering logic
â”‚   â”œâ”€â”€ TodoItem.tsx        # Single todo display
â”‚   â”œâ”€â”€ TodoForm.tsx        # Reusable form (create/edit)
â”‚   â”œâ”€â”€ LoadingSpinner.tsx  # Loading state UI
â”‚   â””â”€â”€ ErrorMessage.tsx    # Error state UI
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ api.ts              # API client functions
â”‚   â”œâ”€â”€ types.ts            # TypeScript interfaces
â”‚   â””â”€â”€ validation.ts       # Client-side validation
â””â”€â”€ error.tsx               # Global error boundary
```

**Routing Strategy**
- `/` â†’ Redirects to `/todos`
- `/todos` â†’ List all todos
- `/todos/new` â†’ Create new todo
- `/todos/[id]/edit` â†’ Edit specific todo
- Dynamic routes use Next.js `[id]` convention
- All todo data pages are Client Components (`'use client'`)

### 2.2 Data Fetching Strategy

**Client-Side Fetching Pattern**
- Use native `fetch` API in Client Components
- No Server Components for data fetching (per specification)
- Wrap fetch calls in `useEffect` hooks or event handlers
- Implement custom `useTodos` and `useTodo` hooks for reusability

**Fetch Lifecycle Management**
```
Component Mount
    â†“
Initiate Fetch (set loading=true)
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Success   â”‚    Error    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Update Data â”‚ Set Error   â”‚
â”‚ loading=falseâ”‚ loading=falseâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
Render UI (data/error/loading)
```

**Caching Strategy**
- Browser cache: Leverage `Cache-Control` headers from backend
- No frontend cache layer (SWR/React Query) in initial implementation
- Refetch data after mutations (POST/PUT/DELETE)
- Use optimistic UI updates for perceived performance

**Retry Logic**
- Exponential backoff for failed requests (100ms, 200ms, 400ms)
- Maximum 3 retry attempts
- Display retry button on persistent failures
- Differentiate between network errors and 4xx/5xx responses

### 2.3 State Management Approach

**Component-Level State (useState)**
- Form inputs: `const [title, setTitle] = useState('')`
- Loading flags: `const [isLoading, setIsLoading] = useState(false)`
- Error messages: `const [error, setError] = useState<string | null>(null)`
- Each page manages its own state independently

**No Global State Management**
- No Redux, Zustand, or Context API for todos
- API is source of truth, not client state
- State duplication between pages is acceptable (simplicity over DRY)

**State Synchronization Pattern**
1. User submits form â†’ Optimistically update local state
2. Send API request â†’ Set loading state
3. On success â†’ Navigate to list page (fresh fetch)
4. On failure â†’ Revert optimistic update, show error

### 2.4 Error and Loading Handling

**Loading States**
- **Initial Load**: Full-page skeleton or spinner
- **Form Submission**: Disabled button with spinner icon
- **Delete Operation**: Loading indicator on delete button
- **Retry Action**: Spinner on retry button

**Error State Taxonomy**
1. **Network Errors** (fetch failed)
   - Message: "Cannot reach server. Check connection."
   - Action: Retry button
2. **Validation Errors** (400, 422)
   - Message: Field-specific errors below inputs
   - Action: Fix input, resubmit
3. **Not Found** (404)
   - Message: "Todo not found. It may have been deleted."
   - Action: Return to list button
4. **Server Errors** (500)
   - Message: "Something went wrong. Please try again."
   - Action: Retry button

**Error Boundary Strategy**
- Global `error.tsx` catches unhandled component errors
- Page-level try/catch for API calls
- No error thrown for expected failures (404, validation)

### 2.5 Component Design Patterns

**TodoForm Component (Shared)**
- Props: `initialData?: Todo`, `onSubmit: (data) => Promise<void>`, `onCancel: () => void`
- Manages internal form state
- Performs client-side validation before submission
- Displays inline validation errors
- Used by both `/todos/new` and `/todos/[id]/edit`

**TodoList Component**
- Props: `todos: Todo[]`, `onDelete: (id) => Promise<void>`, `onToggleComplete: (id) => Promise<void>`
- Renders array of TodoItem components
- Handles empty state display
- Provides callback functions for actions

**TodoItem Component**
- Props: `todo: Todo`, `onDelete: () => void`, `onToggleComplete: () => void`
- Displays single todo with completion status
- Provides quick action buttons (complete/delete)
- Links to edit page

---

## 3. Backend Architecture

### 3.1 FastAPI Application Structure

**Project Layout**
```
backend/
â”œâ”€â”€ main.py                 # FastAPI app initialization, CORS
â”œâ”€â”€ routers/
â”‚   â””â”€â”€ todos.py            # All todo endpoints
â”œâ”€â”€ models/
â”‚   â”œâ”€â”€ database.py         # SQLAlchemy engine, session
â”‚   â””â”€â”€ todo.py             # Todo ORM model
â”œâ”€â”€ schemas/
â”‚   â”œâ”€â”€ todo.py             # Pydantic request/response models
â”‚   â””â”€â”€ error.py            # Error response schemas
â”œâ”€â”€ services/
â”‚   â””â”€â”€ todo_service.py     # Business logic layer
â”œâ”€â”€ dependencies.py         # Dependency injection (DB session)
â””â”€â”€ database.db             # SQLite file (created at runtime)
```

**Layered Architecture**
```
HTTP Request
    â†“
Router (todos.py) â”€â”€â”€â”€â†’ Validates input (Pydantic)
    â†“
Service Layer â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ Business logic
    â†“
ORM Model â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ Database operations
    â†“
SQLite Database
```

### 3.2 API Route Organization

**Single Router for Todos**
- All `/todos/*` endpoints in `routers/todos.py`
- Router registered with prefix `/todos` in `main.py`
- Endpoint functions named by action: `list_todos`, `create_todo`, `get_todo`, `update_todo`, `delete_todo`

**Dependency Injection Pattern**
- Database session injected via FastAPI `Depends()`
- Example: `def get_todo(id: str, db: Session = Depends(get_db))`
- Ensures proper session lifecycle (open â†’ use â†’ close)

**Route Handler Responsibilities**
1. Parse and validate request (Pydantic)
2. Extract dependencies (DB session)
3. Call service layer function
4. Handle service layer exceptions
5. Return appropriate HTTP response

### 3.3 Request/Response Models (Pydantic)

**Schema Design Philosophy**
- Separate schemas for input and output
- Input schemas validate and coerce types
- Output schemas serialize database models
- Avoid exposing internal database IDs directly (use UUIDs)

**Core Schemas**
1. **TodoCreate** (POST request body)
   - Fields: `title: str`, `description: str | None`
   - Validators: title length (1-200), description length (0-2000)
2. **TodoUpdate** (PUT/PATCH request body)
   - Fields: `title: str | None`, `description: str | None`, `completed: bool | None`
   - All fields optional (partial update)
3. **TodoResponse** (All responses)
   - Fields: `id: str`, `title: str`, `description: str`, `completed: bool`, `created_at: datetime`
   - Used by GET, POST, PUT responses
4. **ErrorResponse** (Error responses)
   - Fields: `detail: str | list[dict]`
   - Consistent across all error codes

**Validation Strategy**
- Pydantic validators for field constraints (length, format)
- Custom validators for business rules (e.g., whitespace-only titles)
- FastAPI automatically returns 422 for schema mismatches
- Manual 400 responses for business logic validation failures

### 3.4 Service Layer Design

**Purpose of Service Layer**
- Encapsulate business logic separate from HTTP concerns
- Provide transaction boundaries for database operations
- Raise domain-specific exceptions (converted to HTTP errors by router)

**Service Function Signatures**
- `get_all_todos(db: Session) -> list[TodoModel]`
- `get_todo_by_id(db: Session, todo_id: str) -> TodoModel | None`
- `create_todo(db: Session, data: TodoCreate) -> TodoModel`
- `update_todo(db: Session, todo_id: str, data: TodoUpdate) -> TodoModel | None`
- `delete_todo(db: Session, todo_id: str) -> bool`

**Exception Handling**
- Service layer raises `TodoNotFoundException` for missing todos
- Service layer raises `ValidationException` for business rule violations
- Router catches these and converts to HTTP 404, 400 responses

### 3.5 Database Access Layer

**SQLAlchemy ORM Approach**
- Define Todo model with SQLAlchemy declarative base
- Use session-based queries (no raw SQL)
- Session lifecycle managed by FastAPI dependency

**Connection Management**
- Single SQLite file connection
- Connection pooling handled by SQLAlchemy
- Sessions are request-scoped (created per request, closed after)

**Migration Strategy**
- Use SQLAlchemy `create_all()` for initial schema
- No migration framework (Alembic) required for Phase II
- Schema changes require database recreation (acceptable for development)

---

## 4. Data Model

### 4.1 Todo Entity Definition

**Database Table: `todos`**

| Column       | Type      | Constraints                  | Purpose                          |
|--------------|-----------|------------------------------|----------------------------------|
| id           | VARCHAR   | PRIMARY KEY, UNIQUE          | UUID v4 identifier               |
| title        | VARCHAR   | NOT NULL, MAX LENGTH 200     | Todo title text                  |
| description  | TEXT      | NULLABLE                     | Optional detailed notes          |
| completed    | BOOLEAN   | NOT NULL, DEFAULT FALSE      | Completion status                |
| created_at   | TIMESTAMP | NOT NULL, DEFAULT CURRENT    | Creation timestamp (UTC)         |

**Field Design Decisions**

- **id**: UUID v4 string (not auto-incrementing integer)
  - Rationale: Prevents enumeration attacks, future-proof for distributed systems
  - Format: `550e8400-e29b-41d4-a716-446655440000`

- **title**: Variable-length string
  - Stored trimmed (whitespace removed from start/end at service layer)
  - Enforced at both service and database layer

- **description**: Unlimited text field (TEXT type)
  - Nullable to differentiate between empty string and no description
  - Stored as-is (whitespace preserved)

- **completed**: Boolean flag with default false
  - Only two states: true (completed) or false (incomplete)
  - Indexed for efficient filtering

- **created_at**: Immutable timestamp
  - Set once at creation, never updated
  - Stored in UTC to avoid timezone issues
  - Used for default sort order (newest first)

### 4.2 Status Handling Philosophy

**Completion State Machine**
```
         [Create]
            â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  Incomplete  â”‚ â†â”€â”€â”
    â”‚ completed=F  â”‚    â”‚ [Toggle]
    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
           â”‚            â”‚
    [Toggle]            â”‚
           â”‚            â”‚
           â†“            â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
    â”‚   Completed  â”‚ â”€â”€â”€â”˜
    â”‚ completed=T  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
       [Delete]
           â†“
       (Removed from database)
```

**No Soft Deletes**
- Deleted todos are permanently removed from database
- No `deleted_at` or `is_deleted` field
- Simplifies queries (no need to filter deleted records)

**No Additional States**
- No "archived", "in-progress", "paused" states
- Phase II intentionally minimal (binary completed status)
- Future phases may introduce state enumeration

---

## 5. API Design (High-Level)

### 5.1 Endpoint Inventory

**Resource: `/todos`**

| Method | Endpoint        | Purpose                              | Request Body       | Success Response      |
|--------|-----------------|--------------------------------------|--------------------|-----------------------|
| GET    | `/todos`        | Retrieve all todos                   | None               | 200 + Todo array      |
| POST   | `/todos`        | Create new todo                      | TodoCreate         | 201 + Created todo    |
| GET    | `/todos/{id}`   | Retrieve single todo by ID           | None               | 200 + Todo object     |
| PUT    | `/todos/{id}`   | Update existing todo (full replace)  | TodoUpdate         | 200 + Updated todo    |
| DELETE | `/todos/{id}`   | Permanently delete todo              | None               | 204 (No content)      |

**PATCH Alternative**
- `PATCH /todos/{id}` can be used instead of PUT for partial updates
- Backend treats PUT and PATCH identically (both allow partial fields)
- Frontend should use PUT for consistency

### 5.2 HTTP Method Semantics

**GET /todos** (List)
- Idempotent: Yes
- Side effects: None
- Caching: Safe to cache with short TTL (e.g., 30 seconds)
- Empty result: Returns `[]` with 200, not 404

**POST /todos** (Create)
- Idempotent: No (creates new resource on each call)
- Side effects: New database record
- Response includes full created object with server-generated fields (id, created_at)
- Successful response includes `Location` header with new resource URI

**GET /todos/{id}** (Read Single)
- Idempotent: Yes
- Side effects: None
- 404 if ID doesn't exist (not 400)

**PUT /todos/{id}** (Update)
- Idempotent: Yes (same request multiple times = same final state)
- Side effects: Modified database record
- Updates only provided fields (partial update)
- Returns full updated object

**DELETE /todos/{id}** (Delete)
- Idempotent: Yes (deleting already-deleted resource returns 204)
- Side effects: Record removed from database
- 204 No Content on success (no response body)
- 404 if trying to delete non-existent resource

### 5.3 Request/Response Contracts

**Request Headers (Client â†’ Server)**
```
Content-Type: application/json
Accept: application/json
```

**Response Headers (Server â†’ Client)**
```
Content-Type: application/json
Access-Control-Allow-Origin: http://localhost:3000  (dev only)
Cache-Control: no-cache  (for mutation endpoints)
```

**Error Response Format** (Consistent across all errors)
```json
{
  "detail": "Human-readable error message"
}
```
OR for validation errors:
```json
{
  "detail": [
    {
      "loc": ["body", "title"],
      "msg": "Title cannot be empty",
      "type": "value_error"
    }
  ]
}
```

**Success Response Formats**

*GET /todos (200)*
```json
[
  {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "title": "Buy groceries",
    "description": "Milk, eggs, bread",
    "completed": false,
    "created_at": "2026-01-18T10:30:00Z"
  }
]
```

*POST /todos (201)*
```json
{
  "id": "660e8400-e29b-41d4-a716-446655440000",
  "title": "New todo",
  "description": "",
  "completed": false,
  "created_at": "2026-01-18T11:00:00Z"
}
```

*DELETE /todos/{id} (204)*
```
(No response body)
```

### 5.4 Status Code Decision Tree

**2xx Success Codes**
- **200 OK**: GET (single/list), PUT/PATCH (update)
- **201 Created**: POST (create) with Location header
- **204 No Content**: DELETE

**4xx Client Error Codes**
- **400 Bad Request**: Validation failure (empty title, too long, invalid type)
- **401 Unauthorized**: Missing or invalid JWT token
- **403 Forbidden**: Valid token but user doesn't own the resource
- **404 Not Found**: Resource doesn't exist (GET/PUT/DELETE non-existent ID)
- **422 Unprocessable Entity**: Request body doesn't match schema

**5xx Server Error Codes**
- **500 Internal Server Error**: Database connection failure, unexpected exceptions

---

## 6. System Flow

### 6.1 Happy Path: Create Todo Flow

```
User fills form â†’ Clicks "Save"
    â†“
Frontend validates title (client-side)
    â†“
POST /todos {title, description}
    â†“
Backend Pydantic validates schema
    â†“
Service layer trims title, validates business rules
    â†“
Generate UUID, set created_at=now(), completed=false
    â†“
SQLAlchemy INSERT INTO todos
    â†“
Database commits transaction
    â†“
Return 201 + created todo JSON
    â†“
Frontend receives response
    â†“
Navigate to /todos (triggers fresh GET /todos)
    â†“
Display updated list with new todo
```

### 6.2 Happy Path: Toggle Complete Flow

```
User clicks checkbox on todo item
    â†“
Frontend optimistically updates UI (strikethrough)
    â†“
PUT /todos/{id} {completed: !currentValue}
    â†“
Backend retrieves todo from database
    â†“
Update completed field
    â†“
SQLAlchemy UPDATE todos SET completed=X WHERE id=Y
    â†“
Return 200 + updated todo
    â†“
Frontend confirms optimistic update (or reverts on error)
```

### 6.3 Error Flow: Network Failure

```
User submits form
    â†“
POST /todos â†’ fetch() throws NetworkError
    â†“
Frontend catch block detects network error
    â†“
Retry logic: Wait 100ms, retry
    â†“
Second attempt fails
    â†“
Wait 200ms, retry
    â†“
Third attempt fails
    â†“
Display error: "Cannot reach server. Check connection."
    â†“
Show "Retry" button
    â†“
User clicks Retry â†’ Restart flow
```

### 6.4 Error Flow: Validation Failure

```
User submits form with empty title
    â†“
Frontend validation detects empty title
    â†“
Display inline error: "Title is required"
    â†“
Submit button remains disabled
    â†“
User enters title, resubmits
    â†“
POST /todos {title: "   "} (whitespace only)
    â†“
Backend validator detects whitespace-only title
    â†“
Return 400 {detail: "Title cannot be empty or whitespace"}
    â†“
Frontend displays error below input
    â†“
User corrects input
```

### 6.5 Error Flow: 404 Not Found

```
User navigates to /todos/invalid-uuid-123/edit
    â†“
Frontend fetches GET /todos/invalid-uuid-123
    â†“
Backend queries database, finds no match
    â†“
Return 404 {detail: "Todo with id 'invalid-uuid-123' not found"}
    â†“
Frontend error.tsx boundary catches (or page-level handler)
    â†“
Display: "Todo not found. It may have been deleted."
    â†“
Show "Return to List" button
```

### 6.6 Concurrent Update Scenario

```
Tab A: User loads todo (title: "Old Title")
Tab B: User loads same todo
    â†“
Tab A: User edits to "Title A", submits
    â†“
Backend updates database (title â†’ "Title A")
    â†“
Tab A refreshes, sees "Title A"
    â†“
Tab B: User (unaware) edits to "Title B", submits
    â†“
Backend updates database (title â†’ "Title B")
    â†“
Result: Last write wins ("Title B")
    â†“
Phase II accepts this behavior (no conflict detection)
```

---

## 7. Non-Functional Considerations

### 7.1 Maintainability

**Code Organization Principles**
- **Separation of concerns**: UI logic (frontend), business logic (service), data access (ORM)
- **Single Responsibility**: Each component/function has one clear purpose
- **DRY (Don't Repeat Yourself)**: Shared validation logic in reusable functions
- **Convention over Configuration**: Follow Next.js and FastAPI conventions

**Documentation Strategy**
- Inline comments for complex logic only (prefer self-documenting code)
- README files for setup instructions (frontend, backend)
- OpenAPI spec auto-generated by FastAPI (serves as API documentation)
- TypeScript interfaces serve as frontend data documentation

**Naming Conventions**
- **Frontend**:
  - Components: PascalCase (`TodoList.tsx`)
  - Functions: camelCase (`fetchTodos()`)
  - Types: PascalCase (`Todo`, `TodoFormData`)
- **Backend**:
  - Files: snake_case (`todo_service.py`)
  - Functions: snake_case (`create_todo()`)
  - Classes: PascalCase (`TodoModel`, `TodoCreate`)

### 7.2 Separation of Concerns

**Layer Boundaries**

| Layer              | Responsibilities                                      | Should NOT                          |
|--------------------|-------------------------------------------------------|-------------------------------------|
| Frontend Component | Render UI, handle user input, manage local state     | Access database, contain SQL        |
| API Client         | HTTP requests, serialization, error handling          | Contain business logic              |
| Backend Router     | Parse requests, validate, route to services           | Directly query database             |
| Service Layer      | Business logic, orchestrate database operations       | Know about HTTP (status codes)      |
| ORM Model          | Map database rows to objects                          | Contain validation or business rules|
| Database           | Store and retrieve data reliably                      | Contain application logic           |

**Cross-Cutting Concerns**
- **Validation**:
  - Client-side: Immediate feedback, prevent unnecessary requests
  - Server-side: Authoritative, cannot be bypassed
  - Both layers validate independently (defense in depth)
- **Error Handling**:
  - Service layer raises domain exceptions
  - Router translates to HTTP responses
  - Frontend translates to user messages
- **Logging**:
  - Frontend: Console errors in development only
  - Backend: Structured logging to stdout (compatible with cloud logging)

### 7.3 Testability

**Frontend Testing Strategy**
- **Unit Tests**: Utility functions (validation, formatting)
  - Example: Test title trimming function
- **Component Tests**: Isolated component rendering
  - Example: Test TodoForm renders with initial data
- **Integration Tests**: API client functions with mocked fetch
  - Example: Test createTodo() handles 400 error correctly

**Backend Testing Strategy**
- **Unit Tests**: Service layer functions with mocked database
  - Example: Test `create_todo()` generates UUID correctly
- **Integration Tests**: Full request/response cycle with test database
  - Example: POST /todos returns 201 with correct data
- **Schema Tests**: Pydantic models validate correctly
  - Example: TodoCreate rejects empty title

**Test Database Strategy**
- Use in-memory SQLite (`:memory:`) for fast test execution
- Each test creates fresh schema (isolated)
- No shared state between tests

**Mocking Strategy**
- Frontend: Mock `fetch()` calls in tests
- Backend: Mock database session for unit tests
- Use real database for integration tests

### 7.4 Scalability Considerations (Future-Proofing)

**Current Phase II Limitations (Acceptable)**
- Single SQLite file (not horizontally scalable)
- No caching layer (every request hits database)
- No connection pooling optimizations
- No database indexes beyond primary key

**Migration Paths (Not Implemented Now)**
- SQLite â†’ PostgreSQL: Change connection string, schema compatible
- Add Redis cache: Insert caching layer in service layer
- Add database indexes: Add to ORM models, create migration
- Split frontend/backend to different servers: Already separated

### 7.5 Security Considerations

**Input Validation**
- All user input validated at multiple layers
- SQL injection prevented by ORM (no raw SQL)
- XSS prevented by React auto-escaping
- No file uploads (reduces attack surface)

**CORS Configuration**
- Development: Allow `localhost:3000`
- Production: Configure allowed origin explicitly
- Never use `*` wildcard in production

**Error Message Safety**
- Never expose stack traces to users
- Database errors return generic "Internal error" message
- Validation errors reveal only necessary information

**Authentication & Authorization**
- Phase II has none (explicitly out of scope)
- All endpoints public and unauthenticated
- Single-user assumption (no data separation)

### 7.6 Performance Optimization Opportunities

**Phase II Performance Targets**
- Initial page load: < 3 seconds on 3G
- Todo list render: < 100ms for 100 todos
- API response time: < 200ms (99th percentile)

**Optimization Strategies (Applied Selectively)**
- **Frontend**:
  - Use React.memo for TodoItem if list > 50 todos
  - Implement virtual scrolling if list > 500 todos (not in Phase II)
  - Code splitting: Next.js automatic route-based splitting
- **Backend**:
  - Add database index on `created_at` if sorting becomes slow
  - Use database connection pooling (SQLAlchemy default)
  - Implement pagination if list > 1000 todos (not in Phase II)

**Premature Optimization Avoidance**
- No caching until latency measured as problem
- No indexes until query performance measured
- No virtual scrolling until list size requires it

### 7.7 Error Recovery and Resilience

**Frontend Resilience**
- Retry failed requests with exponential backoff
- Graceful degradation on API unavailable (show cached data if available)
- Clear error messages guide user to resolution

**Backend Resilience**
- Database connection retries on transient failures
- Transaction rollback on errors (atomic operations)
- Graceful handling of malformed requests (no crashes)

**Data Integrity**
- ACID transactions prevent partial writes
- Foreign key constraints (if added later) enforced at database
- Unique constraints prevent duplicate IDs

---

## 8. Technology-Specific Decisions

### 8.1 Next.js Specific Choices

**Rendering Strategy**
- App Router with Client Components for all data pages
- Server Components only for static layouts (no data fetching)
- No use of `'use server'` directives (Phase II has no server actions)

**Routing Approach**
- File-system routing (no custom route configuration)
- Dynamic routes for todo ID: `[id]` folder
- Nested routes for edit: `[id]/edit/page.tsx`

**API Routes (Optional)**
- Option A: Frontend fetch directly to `localhost:8000`
- Option B: Create Next.js API routes in `app/api/` that proxy to backend
- Recommendation: Option A for simplicity (CORS-enabled backend)

### 8.2 FastAPI Specific Choices

**Async vs Sync**
- Use async route handlers (`async def`) for I/O operations
- Database queries use async SQLAlchemy if drivers support (or sync is acceptable)
- Benefit: Better concurrency under load

**Dependency Injection**
- Database session via `Depends(get_db)`
- No authentication dependencies (Phase II unauthenticated)
- Reusable dependencies for common validations

**Validation**
- Pydantic V2 models for all request/response schemas
- Custom validators for business rules (e.g., `@field_validator`)
- Use `ConfigDict` for ORM mode compatibility

**Middleware**
- CORS middleware for cross-origin requests
- Exception handlers for custom error responses
- Request logging middleware (optional, development only)

### 8.3 SQLAlchemy Specific Choices

**ORM vs Core**
- Use ORM (declarative models) for CRUD simplicity
- No need for Core (raw SQL expressions)

**Session Management**
- Session-per-request pattern via dependency injection
- Auto-commit disabled (explicit commits only)
- Sessions closed automatically by FastAPI lifecycle

**Relationship Mapping**
- Phase II has single entity (no relationships)
- Future phases may add relationships (e.g., Todo â†’ Tags)

---

## 9. Architecture Trade-Offs

### 9.1 Decisions and Rationale

**Decision: SQLite vs PostgreSQL**
- **Chosen**: SQLite for development
- **Rationale**: Zero configuration, file-based, sufficient for single-node
- **Trade-off**: Not horizontally scalable (acceptable for Phase II)
- **Migration Path**: Change connection string to PostgreSQL, schema compatible

**Decision: Client-Side Fetching vs Server-Side Rendering**
- **Chosen**: Client-side fetching in Client Components
- **Rationale**: Specification requires client-side data fetching
- **Trade-off**: Slower initial render, SEO-unfriendly (acceptable for todo app)

**Decision: No Global State Management**
- **Chosen**: Component-level state only
- **Rationale**: Simplicity, API is source of truth
- **Trade-off**: Data refetched on navigation (acceptable, promotes fresh data)

**Decision: UUID vs Auto-Incrementing IDs**
- **Chosen**: UUID v4
- **Rationale**: Prevents enumeration, future-proof for distributed systems
- **Trade-off**: Larger storage size, less human-readable (acceptable)

**Decision: No Soft Deletes**
- **Chosen**: Hard deletes (permanent removal)
- **Rationale**: Simplifies queries, no "undo" requirement in Phase II
- **Trade-off**: Cannot recover deleted todos (acceptable per spec)

**Decision: Last-Write-Wins for Concurrent Edits**
- **Chosen**: No conflict detection
- **Rationale**: Simpler implementation, rare in single-user context
- **Trade-off**: Possible data loss in multi-tab scenario (acceptable for Phase II)

### 9.2 Future Architecture Evolution

**Phase III Potential Enhancements**
- Add PostgreSQL for production deployment
- Implement optimistic locking (version field) for conflict detection
- Add Redis cache for list endpoint
- Introduce authentication (user-scoped todos)
- Add WebSocket for real-time sync across tabs

**Architectural Flexibility**
- Current design supports these additions without major refactor
- Service layer can be extended with new business logic
- Database can be swapped via ORM abstraction
- Frontend API client can be replaced with library (Axios, React Query)

---

## 10. Architecture Validation Checklist

**Does this architecture satisfy Phase II requirements?**

- [x] Manages todos via modern web interface (Next.js App Router)
- [x] Fast, responsive UX (client-side fetching, optimistic updates)
- [x] Predictable UX (clear loading and error states)
- [x] CRUD operations (all five endpoints defined)
- [x] Mark complete/incomplete (PUT endpoint with completed field)
- [x] Persist across sessions (Neon PostgreSQL database)
- [x] Backend via REST APIs (FastAPI with JSON)
- [x] Frontend communicates only via APIs (no direct database access)
- [x] Data persists after refresh (database storage)
- [x] Clear error messages (error response schemas)
- [x] Clean UX with no crashes (error boundaries, validation)

**Is the architecture maintainable?**

- [x] Clear separation of concerns (layers defined)
- [x] Single responsibility (components, services focused)
- [x] Testable design (mockable dependencies)
- [x] Self-documenting (TypeScript types, OpenAPI spec)

**Is the architecture flexible for future phases?**

- [x] Database can be swapped (ORM abstraction)
- [x] Authentication can be added (middleware layer ready)
- [x] Caching can be inserted (service layer abstraction)
- [x] New features fit existing patterns (extensible service layer)

---

## Document Version
- **Version**: 1.0
- **Phase**: II â€” Full-Stack Web Todo Application
- **Document Type**: Implementation Plan (Architecture & Design)
- **Depends On**: Phase II Specification v1.0
- **Last Updated**: 2026-01-18
- **Next Document**: Implementation Tasks (Task Breakdown)
```

## Response snapshot

Analysis of Phase II artifacts revealed 1 CRITICAL issue (Todo model using integer IDs instead of UUIDs as required by constitution), 1 HIGH issue (missing authentication implementation), and several MEDIUM/LOW issues. The specification and plan are well-aligned with 100% task coverage, but require updates to comply with constitution requirements for UUID-based IDs and authentication implementation.

## Outcome

- âœ… Impact: Identified critical constitution violation requiring model update
- ğŸ§ª Tests: none
- ğŸ“ Files: Analyzed specs/phase-ii/spec.md, specs/phase-ii/plan.md, specs/phase-ii/tasks.md
- ğŸ” Next prompts: Update Todo model to use UUIDs and implement authentication
- ğŸ§  Reflection: Architecture is sound but needs constitution compliance fixes

## Evaluation notes (flywheel)

- Failure modes observed: 1 critical constitution violation (ID type)
- Graders run and results (PASS/FAIL): FAIL (critical issues found)
- Prompt variant (if applicable): N/A
- Next experiment (smallest change to try): Update Todo model to use UUIDs as required